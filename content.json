{"posts":[{"title":"Acwing 913.排队打水题解","text":"Acwing 913.排队打水 思路：可以得出当排队时间按升序打水，等待时间最短 数学证明：反证法 有n个人，对第i个和第i+1个打水的人，他们的打水时间为 $t_i$, $t_{i+1}$ ($t_i$ &lt; $t_{i+1}$) 若按升序打水时间$T_1$ = $t_i$ * (n - i) + $t_{i+1}$ * (n-i-1) 若两者顺序转换: $T_2$ = $t_{i+1}$ * (n - i) + $t_i$ * (n - i - 1) $T_1$ - $T_2$ = $t_i$ - $t_{i+1}$ &lt; 0 以此类推可知升序时间最小 c++代码12345678910111213141516171819202122232425262728293031323334/* * @Author: Awesome_ZC * @Date: 2021-08-29 15:22:21 * @Version: 1.0 */#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n;int a[N];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); sort(a, a + n); LL ans = 0; for(int i = n -1, j = 0; i &gt;= 1; i --, j ++) ans += i * a[j]; cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2022/04/06/Acwing%20913.%E6%8E%92%E9%98%9F%E6%89%93%E6%B0%B4%E9%A2%98%E8%A7%A3/"},{"title":"Stories About C Plus Plus","text":"🧀 Knowing, learning and mastering c++ is a cool thing in my opinion. Like a chef with a handy kitchen knife, you can do a lot of interesting things with c++. This learning note is mainly about some c++ points. Wish myself an early glimpse of c++. staticthis指针inline12345678910111213141516171819//inline.h#ifndef BASE_INLINE_H#define BASE_INLINE_Hclass A{public: int foo1(int x, int y); void Foo(int x, int y) { }; void f1(int x);};#endif //BASE_INLINE_H 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;inline.h&quot;using namespace std;int Foo(int x, int y);inline int Foo(int x, int y){ return x + y;}//定义处添加inline（显示声明）推荐inline void A::f1(int x){}int main(){ cout &lt;&lt; Foo(1,2) &lt;&lt; endl;} 声明方式inline 对编译器来说是一条指令而非命令，可以显示声明可以隐式声明。 显示声明：==inline==修饰符 123456int foo(int x, int y); //函数声明inline int foo(int x, int y) // 函数定义{ return x + y;} 隐式声明：类中方法的定义 12345class A{public: int foo1(int x, int y); //隐式声明} 使用场景首先了解编译器对inline的处理 将inline函数体复制到调用处 为inline函数中的局部变量分配内存空间 将inline函数的输入参数和返回值映射到调用方法的局部空间中 inline若有多个返回点将其转变为 inline 函数代码块末尾的分支（使用 GOTO） 内联函数能够提高函数效率，实质上就是将函数直接复制，一耗费更过空间为代价省去了函数调用的开销。提高函数执行效率。以下场景不适合使用 函数代码执行时间相比于函数调用花费时间长 函数代码段较长，函数体内出现循环。 虚函数的vptr与vtable 一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时 //todo assert 断言 断言是宏在&lt;assert.h&gt;头文件中，而非函数。 通过定义NDEBUG关闭assert，定义在源码开头，#include&lt;assert.h&gt;之前 为何使用/与正常错误处理 断言用于检查逻辑上不可能的情况如：检查源码在运行前期望的状态或者在运行完成后的检查状态 与正常错误处理不同断言通常在运行时被禁用 12345678910111213141516171819//#define NDEBUG 定义后assert不可用#include &lt;iostream&gt;#include &lt;assert.h&gt;using namespace std;int main(){ int x = 7; //some code x = 9; //some code assert(x==7); return 0;} extern”c” and extern “C++”extern 用于c++ 链接c语言中定义的函数 在编译阶段，c++编译生成的文件中可能有些符号与C语言生成的不同，比如c++中的重载，多态等。extern的作用便是：告诉链接器去寻找c语言符号而不是经过c++修饰后的符号 ``先看一个错误的例子 1234567891011121314151617181920212223242526272829//add.h#ifdef BASE_ADD_Hextern &quot;C&quot; {#endifint add(int x, int y);#ifdef BASE_ADD_H}#endif //BASE_ADD_H//add.c#include &lt;stdio.h&gt;#include &quot;add.h&quot;int add(int x, int y){ return x + y;}//add.cpp#include &lt;iostream&gt;using namespace std;extern &quot;C&quot;{#include &quot;add.h&quot;}int main(){ add(2,3); return 0;} error: ‘add’ was not declared in this scope 在stdio.h标准库中 123#ifdef __cplusplusextern &quot;C&quot; {#endif c++ 在调用接口时以C接口调用。这种写法使得c++在调用时不需要额外写externa “C” C与C++中struct的区别 C C++ 结构体中无函数 可有函数 无访问修饰符，默认public protect, private,public 定义的结构体变量，使用时必须加上 struct 可不加 无继承 可继承 若结构体的名字与函数名相同，可以正常运行且正常的调用 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义 friend友元函数：可以理解为静态函数，需单独实现，能够访问类的私有和保护成员友元类： 同理见实例 特点破坏了封装性，提高了运行效率 一些性质 不可传递性: A是B的友元类，B是C的友元类，A不是C的友元类 无继承性： B是A的友元类，C继承A，C无法访问B的私有和保护成员 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class A{public: A(int _a):a(_a){}; friend int geta(A a); friend class B; //B是A的友元类，private: int a;};int geta(A a){ return a.a;}class B{public: int getb(A _a){ return _a.a; }};int main(){ A a{2}; B b; cout &lt;&lt; &quot;geta:\\t&quot; &lt;&lt; geta(a) &lt;&lt;endl; cout &lt;&lt; &quot;getb:\\t&quot; &lt;&lt; b.getb(a) &lt;&lt; endl; return 0;} :: 作用域声明作用域 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 123456789101112131415161718192021//From Light-City#include &lt;iostream&gt;using namespace std;int count=0; // 全局(::)的countclass A {public: static int count; // 类A的count (A::count)};// 静态变量必须在此处定义int A::count;int main() { ::count=1; // 设置全局的count为1 A::count=5; // 设置类A的count为2 cout&lt;&lt;A::count&lt;&lt;endl;// int count=3; // 局部count// count=4; // 设置局部的count为4 return 0;} ReferenceLight-City/CPlusPlusThings","link":"/2022/09/02/CPlusPlusThings%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"CommentDemo","text":"Test Comment plugin","link":"/2024/06/23/CommentDemo/"},{"title":"Hexo+Icarus+Github Page配置","text":"Hexo博客搭建网络上参考资料很多这里略过 Github Actions部署 Hexo博客建立私有化仓库私有化仓库来存放自己的博客，New-&gt;Repository Name-&gt;private-&gt;create repository 创建Github Token创建token-&gt;Generate new token-&gt;Generate new token(classic)-&gt;具体配置看下图-&gt;记住生成的token 设置workflow在本地blog根目录下创建*.github\\workflows\\hexo-deploy.yml*文件，具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455name: 自动部署on: push: branches: - master release: types: - publishedjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v3 with: ref: master - name: 安装 Node uses: actions/setup-node@v3 with: node-version: &quot;20.x&quot; - name: 安装 Hexo 和 theme主题 run: | export TZ='Asia/Shanghai' npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v3 id: cache with: path: node_modules key: ${{runner.OS}}-${{hashFiles('**/package-lock.json')}} - name: 安装依赖 if: steps.cache.outputs.cache-hit != 'true' run: | npm install --save - name: 生成静态文件 run: | hexo clean hexo generate - name: 部署 #此处master:master 指从本地的master分支提交到远程仓库的master分支(不是博客的分支写master即可)，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。 run: | cd ./public git init git config --global user.name '${{ secrets.GITHUBUSERNAME }}' git config --global user.email '${{ secrets.GITHUBEMAIL }}' git add . git commit -m &quot;${{ github.event.head_commit.message }} $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot; git push --force --quiet &quot;https://${{ secrets.GITHUBUSERNAME }}:${{ secrets.GITHUBTOKEN }}@github.com/${{ secrets.GITHUBUSERNAME }}/${{ secrets.GITHUBUSERNAME }}.github.io.git&quot; master:master # GitHub配置 上传代码到私有仓库1234git checkout master #确保转到本地master分支git add .git commit -m 'your message'git push origin master # 将本地master推送到远程仓库 最后，查看私有仓库中的Action运行情况，运行完成之后将内容推送到github.io的master分支中 个性化配置文章目录在_config.icarus.yml中添加挂件配置 123456widgets: - type: toc position: left # 是否显示目录项目的序号 index: true 在需要开启目录的文章头部加入toc: true 1234title: 一篇有目录的文章toc: true---文章内容... 进一步，在hexo模板中修改文章的模板scaffolds/post.md，这样每次hexo new ***就会根据模板创建 12345678---title: {{ title }}date: {{ date }}tags:excerpt: 文章摘要toc: true #目录--- 修改布局宽度页面宽度编辑&lt;icarus_directory&gt;/include/style/responsive.styl 123456789+widescreen() .is-1-column .container, .is-2-column .container max-width: $desktop - 0 * $gap width: $desktop - 0 * $gap+fullhd() .is-2-column .container max-width: $widescreen - 0 * $gap width: $widescreen - 0 * $gap 挂件或主内容宽度参考常见问题 自定义字体默认的CDN服务提供商配置： 1234providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome 在修改字体时，我选择直接到Google Fonts中查找。 如我想使用Noto Sans Simplified Chinese和PT Serif字体，在Google Font添加选中两种字体，点击get embaded code后根据html代码修改即可 修改/icarus/layout/common/head.jsx 12345const fontCssUrl = { // default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), default: fontcdn('PT+Serif:wght@400;700&amp;Noto+Sans+SC:wght@100..900', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2') }; 修改/icarus/include/style/base.styl 1$family-sans-serif ?= 'PT Serif', 'Noto Sans SC', sans-serif 文章metadata格式修改Github Discussion1304 Reference Icarus官方文档 Hexo博客搭建之Icarus主题–个性化修改篇 icarus个性化配置 Github+Hexo+icarus创建自定义blog 字体识别 leimao How can I change font? #713","link":"/2024/06/21/Hexo+Icarus+Github%20Page%E9%85%8D%E7%BD%AE/"},{"title":"Way to 云南","text":"Day0下午六点坐飞机晚上八点半左右到了昆明。第一次坐飞机体验到了20分钟从白天到黑夜的全过程。到了酒店之后来了份过桥米线，吃个新鲜，这边的米线需要自己都动手下菜，先荤后素最后米线。吃的时候也是按照这个顺序最后喝鸡汤。夜晚漫步在这个城市给我一种回到了商丘的感觉，没有钢筋水泥高楼大厦，常见平房商铺 Day1上午翠湖公园，公园里只有大爷大妈再跳广场舞，公园外围有零星跑者 接着跑到讲武堂，没什么特色和武汉讲武堂内部结构相似 中午的火锅菌汤，外加牦牛肉，火锅底加上菌类巨鲜 下午的滇池半日游，可惜滇池是个户，在湖边看湖水还是很浑浊，吹吹风倒也不错。还体验了做缆车到一个山上，具体山名忘记了🤣，没往爬直奔昆明老街吃饭 晚上电动车狂飞到云南大学，预约满了没进去 Day2上午计划游玩官渡古镇和云南省博物馆。官渡古镇商业化挺严重，里面大部分是娱乐购物商铺 云南省博物馆和官渡古镇十分接近，步行15mins就到了，正巧是高考第一天，见到了许多考生和家长 中午吃了顿傣味手抓饭，不是很合胃口，偏辣 下午来到大理，第一次买站票 Day3大理第一天，作为旅游城市，大理环境宜人，在城镇公路边几乎见不到垃圾。上午闲逛了大理古城，商业化的同时保留了部分特色比如城里的古道，早晨的菜市场 下午从古镇（那个古镇忘记了）步行到洱海生态廊道。只用15元租辆共享单车即可享受洱海风景。在云南感觉触手就能碰到云朵。 Day4苍山索道+极限爬1111级台阶 Day5在民宿呆了半天，晚上🚝大理-昆明，✈昆明-武汉。准备当天的毕业合照。 遗珠之憾在昆明旅行时候接到了拍毕业合照的通知，打乱了我们的旅行计划。原本打算的香格里拉还没有去，心中的日月成为遗珠之憾，还会再回来的。","link":"/2024/06/30/Way%20to%20%E4%BA%91%E5%8D%97/"},{"title":"&lt;你想活出怎样的人生&gt;观后感","text":"0.引言随着宫崎骏最后一部作品《你想活出怎样的人生》在影院上映，最近和朋友一起去看了这部电影。我对宫崎骏大师的作品没有谈得上特别喜爱也也算不上讨厌，只是记得小时候第一次看《千与千寻》时对电影中的画风有一丝不适应，但看的多了也慢慢习惯长惊讶于宫崎骏大师天马行空的想象力和剧情中所隐喻的道理。 1. 看完后的不知所措整部电影讲述的是主人公真人的母亲祸害丧生，随父亲和自己小姨（母亲的妹妹）组成新家庭。随着苍鹭的引导进入奇幻世界冒险故事。 宫崎骏大师和吉卜力工作室的制作水准一如既往的优秀，电影画面随意截一帧都可以当作壁纸。然而如此优秀的动画水准剧情很是奇怪。看完整部电影之后我只能从剧情中提到的战争，鹦鹉国王等细节之处感受到电影可能是讲的反战题材。这种细节少之又少，在我看来一部值得人们反思的电影应该是话说三分留七分供观众思考那么《你想活出怎样的人生》话只说了一份，九分让观众思考。 看完之后忽略掉反战的部分我甚至觉得可以改为《寻妈历险记》。 2. 献给自己的告别之作出影院之后我查了下这部电影的相关资料。电影中的剧情和主人公可以说是宫崎骏老爷子的真实写照。伴随着二战战火成长以及战后对战争的反思出现在老爷子的许多作品之中。在我来，在观众看来一些离奇的剧情和人物在宫崎骏老爷子心中总有真是的生活写照。","link":"/2024/04/06/%E4%BD%A0%E6%83%B3%E6%B4%BB%E5%87%BA%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BA%BA%E7%94%9F-%E8%A7%82%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Journey","slug":"Journey","link":"/tags/Journey/"}],"categories":[{"name":"生活碎片","slug":"生活碎片","link":"/categories/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"}],"pages":[]}